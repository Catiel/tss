package com.simulation.gui; // Declaraci√≥n del paquete que contiene las clases de interfaz gr√°fica de usuario (GUI) de la simulaci√≥n

import com.simulation.resources.Location; // Importa la clase Location para acceder a las locaciones del sistema
import com.simulation.statistics.Statistics; // Importa la clase Statistics para acceder a las estad√≠sticas de la simulaci√≥n
import javafx.collections.FXCollections; // Importa la clase FXCollections de JavaFX para crear colecciones observables
import javafx.collections.ObservableList; // Importa la interfaz ObservableList de JavaFX para listas que notifican cambios
import javafx.geometry.Insets; // Importa la clase Insets de JavaFX para definir m√°rgenes y espaciado interno
import javafx.geometry.Side; // Importa la enumeraci√≥n Side de JavaFX para especificar la posici√≥n de elementos (Top, Bottom, Left, Right)
import javafx.scene.chart.*; // Importa todas las clases de gr√°ficas de JavaFX (LineChart, BarChart, etc.)
import javafx.scene.control.Label; // Importa la clase Label de JavaFX para etiquetas de texto
import javafx.scene.control.Tab; // Importa la clase Tab de JavaFX para crear pesta√±as
import javafx.scene.control.TabPane; // Importa la clase TabPane de JavaFX para crear un contenedor con pesta√±as
import javafx.scene.layout.VBox; // Importa la clase VBox de JavaFX para crear un contenedor de layout vertical

import java.util.HashMap; // Importa la clase HashMap de Java para crear mapas clave-valor
import java.util.Map; // Importa la interfaz Map de Java para trabajar con mapas

/** // Inicio del comentario Javadoc de la clase
 * Panel con m√∫ltiples gr√°ficas que se actualizan en tiempo real // Descripci√≥n de la clase
 */ // Fin del comentario Javadoc
public class RealTimeChartsPanel extends VBox { // Declaraci√≥n de la clase p√∫blica RealTimeChartsPanel que extiende VBox para ser un contenedor vertical de gr√°ficas en tiempo real

    private TabPane tabPane; // Variable privada que almacena el panel de pesta√±as que contiene todas las gr√°ficas

    // Gr√°fica 2: Piezas en el sistema
    private LineChart<Number, Number> systemPiecesChart; // Variable privada que almacena la gr√°fica de l√≠neas de piezas en el sistema
    private XYChart.Series<Number, Number> arrivalsSeriesSystem; // Variable privada que almacena la serie de datos de arribos acumulados
    private XYChart.Series<Number, Number> exitsSeriesSystem; // Variable privada que almacena la serie de datos de salidas acumuladas
    private XYChart.Series<Number, Number> inSystemSeries; // Variable privada que almacena la serie de datos de piezas en el sistema

    // Gr√°fica 3: Utilizaci√≥n de locaciones
    private BarChart<String, Number> utilizationChart; // Variable privada que almacena la gr√°fica de barras de utilizaci√≥n de locaciones

    // Gr√°fica 4: Contenido de locaciones en tiempo real
    private LineChart<Number, Number> locationContentChart; // Variable privada que almacena la gr√°fica de l√≠neas de contenido de locaciones
    private Map<String, XYChart.Series<Number, Number>> contentSeriesMap; // Variable privada que almacena un mapa de nombres de locaciones a sus series de datos de contenido

    // Gr√°fica 5: Tiempo promedio en sistema
    private LineChart<Number, Number> avgSystemTimeChart; // Variable privada que almacena la gr√°fica de l√≠neas de tiempo promedio en sistema
    private XYChart.Series<Number, Number> avgTimeSeries; // Variable privada que almacena la serie de datos de tiempo promedio en sistema

    private static final int MAX_DATA_POINTS = 5000; // Constante est√°tica final que define el n√∫mero m√°ximo de puntos de datos antes de aplicar downsampling
    private int updateCounter = 0; // Variable privada que cuenta el n√∫mero de actualizaciones para controlar la frecuencia de actualizaci√≥n, inicializada en 0

    public RealTimeChartsPanel() { // Constructor p√∫blico que inicializa el panel de gr√°ficas en tiempo real sin recibir par√°metros
        setPadding(new Insets(10)); // Establece un margen interno de 10 p√≠xeles en todos los lados del contenedor
        setSpacing(10); // Establece un espaciado de 10 p√≠xeles entre los elementos hijos del VBox

        contentSeriesMap = new HashMap<>(); // Crea un nuevo HashMap vac√≠o para almacenar las series de contenido de cada locaci√≥n

        initializeCharts(); // Llama al m√©todo para inicializar todas las gr√°ficas y pesta√±as
    } // Cierre del constructor RealTimeChartsPanel

    public void initializeState(Statistics stats) { // M√©todo p√∫blico que inicializa el estado de las gr√°ficas con estad√≠sticas iniciales recibiendo el objeto de estad√≠sticas como par√°metro
        reset(); // Llama al m√©todo reset para limpiar todas las gr√°ficas
        double initialTime = Math.max(0, stats.getSimulationDuration()); // Calcula el tiempo inicial como el m√°ximo entre 0 y la duraci√≥n de la simulaci√≥n
        updateSystemPiecesChart(stats, initialTime); // Actualiza la gr√°fica de piezas en el sistema con el tiempo inicial
        updateUtilizationChart(stats, initialTime); // Actualiza la gr√°fica de utilizaci√≥n con el tiempo inicial
        updateLocationContentChart(stats, initialTime); // Actualiza la gr√°fica de contenido de locaciones con el tiempo inicial
        updateAvgSystemTimeChart(stats, initialTime); // Actualiza la gr√°fica de tiempo promedio en sistema con el tiempo inicial
    } // Cierre del m√©todo initializeState

    private void initializeCharts() { // M√©todo privado que inicializa todas las gr√°ficas y crea las pesta√±as
        tabPane = new TabPane(); // Crea una nueva instancia de TabPane para contener las pesta√±as de gr√°ficas
        tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE); // Establece que las pesta√±as no puedan cerrarse por el usuario
    tabPane.setStyle("-fx-font-size: 14px;"); // Establece el tama√±o de fuente del TabPane a 14 p√≠xeles usando CSS

        // Tab 1: Throughput
    // Tab 1: Piezas en Sistema
    Tab systemPiecesTab = new Tab("üì¶ Piezas en el Sistema"); // Crea una nueva pesta√±a con el t√≠tulo y emoji de piezas en el sistema
        systemPiecesTab.setContent(createSystemPiecesChart()); // Establece el contenido de la pesta√±a llamando al m√©todo que crea la gr√°fica de piezas en el sistema

    // Tab 2: Utilizaci√≥n de Locaciones
    Tab utilizationTab = new Tab("üìä Utilizaci√≥n de Locaciones"); // Crea una nueva pesta√±a con el t√≠tulo y emoji de utilizaci√≥n de locaciones
        utilizationTab.setContent(createUtilizationChart()); // Establece el contenido de la pesta√±a llamando al m√©todo que crea la gr√°fica de utilizaci√≥n

    // Tab 3: Contenido de Locaciones
    Tab contentTab = new Tab("üìç Contenido por Locaci√≥n"); // Crea una nueva pesta√±a con el t√≠tulo y emoji de contenido por locaci√≥n
        contentTab.setContent(createLocationContentChart()); // Establece el contenido de la pesta√±a llamando al m√©todo que crea la gr√°fica de contenido de locaciones

    // Tab 4: Tiempo Promedio en Sistema
    Tab avgTimeTab = new Tab("‚è± Tiempo Promedio en Sistema"); // Crea una nueva pesta√±a con el t√≠tulo y emoji de tiempo promedio en sistema
        avgTimeTab.setContent(createAvgSystemTimeChart()); // Establece el contenido de la pesta√±a llamando al m√©todo que crea la gr√°fica de tiempo promedio

    tabPane.getTabs().addAll(systemPiecesTab, utilizationTab, contentTab, avgTimeTab); // Agrega las cuatro pesta√±as al TabPane en el orden especificado

        VBox.setVgrow(tabPane, javafx.scene.layout.Priority.ALWAYS); // Establece que el TabPane debe expandirse verticalmente para ocupar todo el espacio disponible
        getChildren().add(tabPane); // Agrega el TabPane como hijo de este VBox para que sea visible
    } // Cierre del m√©todo initializeCharts

    // ========== GR√ÅFICA 1: PIEZAS EN SISTEMA ==========
    private VBox createSystemPiecesChart() { // M√©todo privado que crea y retorna un VBox conteniendo la gr√°fica de piezas en el sistema
        VBox container = new VBox(10); // Crea un nuevo VBox con espaciado de 10 p√≠xeles entre elementos
        container.setPadding(new Insets(10)); // Establece un margen interno de 10 p√≠xeles en todos los lados del contenedor

        Label title = new Label("Arribos, Salidas y Piezas en Sistema"); // Crea una nueva etiqueta con el t√≠tulo de la gr√°fica
        title.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;"); // Establece el estilo de la etiqueta con fuente de 16 p√≠xeles y negrita usando CSS

        NumberAxis xAxis = new NumberAxis(); // Crea un nuevo eje X num√©rico para la gr√°fica
        xAxis.setLabel("Tiempo (minutos)"); // Establece la etiqueta del eje X como "Tiempo (minutos)"
        xAxis.setAutoRanging(true); // Habilita el auto-ajuste del rango del eje X seg√∫n los datos

        NumberAxis yAxis = new NumberAxis(); // Crea un nuevo eje Y num√©rico para la gr√°fica
        yAxis.setLabel("Cantidad de Piezas"); // Establece la etiqueta del eje Y como "Cantidad de Piezas"
        yAxis.setAutoRanging(true); // Habilita el auto-ajuste del rango del eje Y seg√∫n los datos

        systemPiecesChart = new LineChart<>(xAxis, yAxis); // Crea una nueva gr√°fica de l√≠neas con los ejes X e Y definidos y la asigna a la variable de instancia
        systemPiecesChart.setTitle("Estado del Sistema"); // Establece el t√≠tulo de la gr√°fica como "Estado del Sistema"
        systemPiecesChart.setCreateSymbols(false); // Desactiva la creaci√≥n de s√≠mbolos (puntos) en cada punto de datos para mejorar el rendimiento
        systemPiecesChart.setAnimated(false); // Desactiva las animaciones de la gr√°fica para mejorar el rendimiento

        arrivalsSeriesSystem = new XYChart.Series<>(); // Crea una nueva serie de datos para los arribos
        arrivalsSeriesSystem.setName("Arribos Acumulados"); // Establece el nombre de la serie como "Arribos Acumulados"

        exitsSeriesSystem = new XYChart.Series<>(); // Crea una nueva serie de datos para las salidas
        exitsSeriesSystem.setName("Salidas Acumuladas"); // Establece el nombre de la serie como "Salidas Acumuladas"

        inSystemSeries = new XYChart.Series<>(); // Crea una nueva serie de datos para las piezas en el sistema
        inSystemSeries.setName("En Sistema"); // Establece el nombre de la serie como "En Sistema"

    systemPiecesChart.getData().add(arrivalsSeriesSystem); // Agrega la serie de arribos a la gr√°fica
    systemPiecesChart.getData().add(exitsSeriesSystem); // Agrega la serie de salidas a la gr√°fica
    systemPiecesChart.getData().add(inSystemSeries); // Agrega la serie de piezas en sistema a la gr√°fica

    applyLargeFont(systemPiecesChart); // Aplica un tama√±o de fuente grande a la gr√°fica
    VBox.setVgrow(systemPiecesChart, javafx.scene.layout.Priority.ALWAYS); // Establece que la gr√°fica debe expandirse verticalmente para ocupar todo el espacio disponible
        container.getChildren().addAll(title, systemPiecesChart); // Agrega la etiqueta de t√≠tulo y la gr√°fica al contenedor VBox

        return container; // Retorna el contenedor VBox con la gr√°fica configurada
    } // Cierre del m√©todo createSystemPiecesChart

    // ========== GR√ÅFICA 3: UTILIZACI√ìN ==========
    private VBox createUtilizationChart() { // M√©todo privado que crea y retorna un VBox conteniendo la gr√°fica de utilizaci√≥n
        VBox container = new VBox(10); // Crea un nuevo VBox con espaciado de 10 p√≠xeles entre elementos
        container.setPadding(new Insets(10)); // Establece un margen interno de 10 p√≠xeles en todos los lados del contenedor

        Label title = new Label("Utilizaci√≥n Actual de Locaciones (%)"); // Crea una nueva etiqueta con el t√≠tulo de la gr√°fica
        title.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;"); // Establece el estilo de la etiqueta con fuente de 16 p√≠xeles y negrita usando CSS

        CategoryAxis xAxis = new CategoryAxis(); // Crea un nuevo eje X categ√≥rico para mostrar nombres de locaciones
        xAxis.setLabel("Locaci√≥n"); // Establece la etiqueta del eje X como "Locaci√≥n"

        NumberAxis yAxis = new NumberAxis(); // Crea un nuevo eje Y num√©rico para mostrar porcentajes
        yAxis.setLabel("% Utilizaci√≥n"); // Establece la etiqueta del eje Y como "% Utilizaci√≥n"
        yAxis.setAutoRanging(false); // Desactiva el auto-ajuste del rango del eje Y para establecer valores fijos
        yAxis.setLowerBound(0); // Establece el l√≠mite inferior del eje Y en 0
        yAxis.setUpperBound(105); // Establece el l√≠mite superior del eje Y en 105 (para dar espacio extra arriba del 100%)

        utilizationChart = new BarChart<>(xAxis, yAxis); // Crea una nueva gr√°fica de barras con los ejes X e Y definidos y la asigna a la variable de instancia
        utilizationChart.setTitle("Utilizaci√≥n en Tiempo Real"); // Establece el t√≠tulo de la gr√°fica como "Utilizaci√≥n en Tiempo Real"
        utilizationChart.setLegendVisible(false); // Oculta la leyenda porque solo hay una serie de datos
        utilizationChart.setAnimated(false); // Desactiva las animaciones de la gr√°fica para mejorar el rendimiento

    applyLargeFont(utilizationChart); // Aplica un tama√±o de fuente grande a la gr√°fica
    VBox.setVgrow(utilizationChart, javafx.scene.layout.Priority.ALWAYS); // Establece que la gr√°fica debe expandirse verticalmente para ocupar todo el espacio disponible
        container.getChildren().addAll(title, utilizationChart); // Agrega la etiqueta de t√≠tulo y la gr√°fica al contenedor VBox

        return container; // Retorna el contenedor VBox con la gr√°fica configurada
    } // Cierre del m√©todo createUtilizationChart

    // ========== GR√ÅFICA 4: CONTENIDO DE LOCACIONES ==========
    private VBox createLocationContentChart() { // M√©todo privado que crea y retorna un VBox conteniendo la gr√°fica de contenido de locaciones
        VBox container = new VBox(10); // Crea un nuevo VBox con espaciado de 10 p√≠xeles entre elementos
        container.setPadding(new Insets(10)); // Establece un margen interno de 10 p√≠xeles en todos los lados del contenedor

        Label title = new Label("Contenido de Locaciones en Tiempo Real"); // Crea una nueva etiqueta con el t√≠tulo de la gr√°fica
        title.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;"); // Establece el estilo de la etiqueta con fuente de 16 p√≠xeles y negrita usando CSS

        NumberAxis xAxis = new NumberAxis(); // Crea un nuevo eje X num√©rico para el tiempo
        xAxis.setLabel("Tiempo (minutos)"); // Establece la etiqueta del eje X como "Tiempo (minutos)"
        xAxis.setAutoRanging(true); // Habilita el auto-ajuste del rango del eje X seg√∫n los datos

        NumberAxis yAxis = new NumberAxis(); // Crea un nuevo eje Y num√©rico para la cantidad de piezas
        yAxis.setLabel("Cantidad de Piezas"); // Establece la etiqueta del eje Y como "Cantidad de Piezas"
        yAxis.setAutoRanging(true); // Habilita el auto-ajuste del rango del eje Y seg√∫n los datos

        locationContentChart = new LineChart<>(xAxis, yAxis); // Crea una nueva gr√°fica de l√≠neas con los ejes X e Y definidos y la asigna a la variable de instancia
        locationContentChart.setTitle("Piezas por Locaci√≥n"); // Establece el t√≠tulo de la gr√°fica como "Piezas por Locaci√≥n"
        locationContentChart.setCreateSymbols(false); // Desactiva la creaci√≥n de s√≠mbolos (puntos) en cada punto de datos para mejorar el rendimiento
        locationContentChart.setAnimated(false); // Desactiva las animaciones de la gr√°fica para mejorar el rendimiento
        locationContentChart.setLegendSide(Side.RIGHT); // Establece que la leyenda debe mostrarse en el lado derecho de la gr√°fica

        // Crear series para cada locaci√≥n
        String[] locations = {"LAVADORA", "ALMACEN_PINTURA", "PINTURA", // Define un array con los nombres de las locaciones para las cuales se mostrar√°n series
                             "ALMACEN_HORNO", "HORNO", "INSPECCION"}; // Continuaci√≥n del array de nombres de locaciones

        for (String loc : locations) { // Bucle for-each que itera sobre cada nombre de locaci√≥n en el array
            XYChart.Series<Number, Number> series = new XYChart.Series<>(); // Crea una nueva serie de datos para esta locaci√≥n
            series.setName(loc); // Establece el nombre de la serie como el nombre de la locaci√≥n
            contentSeriesMap.put(loc, series); // Agrega la serie al mapa de series usando el nombre de la locaci√≥n como clave
            locationContentChart.getData().add(series); // Agrega la serie a la gr√°fica
        } // Cierre del bucle for-each

    applyLargeFont(locationContentChart); // Aplica un tama√±o de fuente grande a la gr√°fica
    VBox.setVgrow(locationContentChart, javafx.scene.layout.Priority.ALWAYS); // Establece que la gr√°fica debe expandirse verticalmente para ocupar todo el espacio disponible
        container.getChildren().addAll(title, locationContentChart); // Agrega la etiqueta de t√≠tulo y la gr√°fica al contenedor VBox

        return container; // Retorna el contenedor VBox con la gr√°fica configurada
    } // Cierre del m√©todo createLocationContentChart

    // ========== GR√ÅFICA 5: TIEMPO PROMEDIO EN SISTEMA ==========
    private VBox createAvgSystemTimeChart() { // M√©todo privado que crea y retorna un VBox conteniendo la gr√°fica de tiempo promedio en sistema
        VBox container = new VBox(10); // Crea un nuevo VBox con espaciado de 10 p√≠xeles entre elementos
        container.setPadding(new Insets(10)); // Establece un margen interno de 10 p√≠xeles en todos los lados del contenedor

        Label title = new Label("Tiempo Promedio en Sistema (minutos)"); // Crea una nueva etiqueta con el t√≠tulo de la gr√°fica
        title.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;"); // Establece el estilo de la etiqueta con fuente de 16 p√≠xeles y negrita usando CSS

        NumberAxis xAxis = new NumberAxis(); // Crea un nuevo eje X num√©rico para el tiempo
        xAxis.setLabel("Tiempo (minutos)"); // Establece la etiqueta del eje X como "Tiempo (minutos)"
        xAxis.setAutoRanging(true); // Habilita el auto-ajuste del rango del eje X seg√∫n los datos

        NumberAxis yAxis = new NumberAxis(); // Crea un nuevo eje Y num√©rico para el tiempo promedio
        yAxis.setLabel("Tiempo Promedio (min)"); // Establece la etiqueta del eje Y como "Tiempo Promedio (min)"
        yAxis.setAutoRanging(true); // Habilita el auto-ajuste del rango del eje Y seg√∫n los datos

        avgSystemTimeChart = new LineChart<>(xAxis, yAxis); // Crea una nueva gr√°fica de l√≠neas con los ejes X e Y definidos y la asigna a la variable de instancia
        avgSystemTimeChart.setTitle("Evoluci√≥n del Tiempo Promedio"); // Establece el t√≠tulo de la gr√°fica como "Evoluci√≥n del Tiempo Promedio"
        avgSystemTimeChart.setCreateSymbols(false); // Desactiva la creaci√≥n de s√≠mbolos (puntos) en cada punto de datos para mejorar el rendimiento
        avgSystemTimeChart.setAnimated(false); // Desactiva las animaciones de la gr√°fica para mejorar el rendimiento

        avgTimeSeries = new XYChart.Series<>(); // Crea una nueva serie de datos para el tiempo promedio
        avgTimeSeries.setName("Tiempo Promedio"); // Establece el nombre de la serie como "Tiempo Promedio"
        avgSystemTimeChart.getData().add(avgTimeSeries); // Agrega la serie a la gr√°fica

    applyLargeFont(avgSystemTimeChart); // Aplica un tama√±o de fuente grande a la gr√°fica
    VBox.setVgrow(avgSystemTimeChart, javafx.scene.layout.Priority.ALWAYS); // Establece que la gr√°fica debe expandirse verticalmente para ocupar todo el espacio disponible
        container.getChildren().addAll(title, avgSystemTimeChart); // Agrega la etiqueta de t√≠tulo y la gr√°fica al contenedor VBox

        return container; // Retorna el contenedor VBox con la gr√°fica configurada
    } // Cierre del m√©todo createAvgSystemTimeChart

    /** // Inicio del comentario Javadoc del m√©todo
     * Actualiza todas las gr√°ficas con nuevos datos // Descripci√≥n del m√©todo
     */ // Fin del comentario Javadoc
    public void updateCharts(Statistics stats, double currentTime) { // M√©todo p√∫blico que actualiza todas las gr√°ficas con nuevas estad√≠sticas recibiendo las estad√≠sticas y el tiempo actual como par√°metros
        if (currentTime <= 0) return; // Si el tiempo actual es menor o igual a 0, sale del m√©todo prematuramente

        // Actualizar solo cada N llamadas para mejor rendimiento
        updateCounter++; // Incrementa el contador de actualizaciones
        if (updateCounter % 5 != 0 && currentTime < stats.getSimulationDuration()) { // Condici√≥n que verifica si el contador no es m√∫ltiplo de 5 y la simulaci√≥n a√∫n no ha terminado
            return; // Saltar algunas actualizaciones durante la simulaci√≥n // Sale del m√©todo prematuramente para reducir la frecuencia de actualizaci√≥n y mejorar el rendimiento
        } // Cierre del bloque condicional if

        // 1. Actualizar Piezas en Sistema
        updateSystemPiecesChart(stats, currentTime); // Llama al m√©todo para actualizar la gr√°fica de piezas en el sistema

        // 2. Actualizar Utilizaci√≥n
        updateUtilizationChart(stats, currentTime); // Llama al m√©todo para actualizar la gr√°fica de utilizaci√≥n

        // 3. Actualizar Contenido de Locaciones
        updateLocationContentChart(stats, currentTime); // Llama al m√©todo para actualizar la gr√°fica de contenido de locaciones

        // 4. Actualizar Tiempo Promedio en Sistema
        updateAvgSystemTimeChart(stats, currentTime); // Llama al m√©todo para actualizar la gr√°fica de tiempo promedio en sistema
    } // Cierre del m√©todo updateCharts

    private void updateSystemPiecesChart(Statistics stats, double currentTime) { // M√©todo privado que actualiza la gr√°fica de piezas en el sistema recibiendo las estad√≠sticas y el tiempo actual como par√°metros
        int arrivals = stats.getTotalArrivals(); // Obtiene el n√∫mero total de arribos desde las estad√≠sticas
        int exits = stats.getTotalExits(); // Obtiene el n√∫mero total de salidas desde las estad√≠sticas
        int inSystem = arrivals - exits; // Calcula el n√∫mero de piezas en el sistema restando salidas de arribos

        arrivalsSeriesSystem.getData().add(new XYChart.Data<>(currentTime, arrivals)); // Agrega un nuevo punto de datos a la serie de arribos con el tiempo actual y el n√∫mero de arribos
        exitsSeriesSystem.getData().add(new XYChart.Data<>(currentTime, exits)); // Agrega un nuevo punto de datos a la serie de salidas con el tiempo actual y el n√∫mero de salidas
        inSystemSeries.getData().add(new XYChart.Data<>(currentTime, inSystem)); // Agrega un nuevo punto de datos a la serie de piezas en sistema con el tiempo actual y el n√∫mero calculado

        enforceSeriesLimit(arrivalsSeriesSystem); // Llama al m√©todo para aplicar downsampling a la serie de arribos si excede el l√≠mite de puntos
        enforceSeriesLimit(exitsSeriesSystem); // Llama al m√©todo para aplicar downsampling a la serie de salidas si excede el l√≠mite de puntos
        enforceSeriesLimit(inSystemSeries); // Llama al m√©todo para aplicar downsampling a la serie de piezas en sistema si excede el l√≠mite de puntos
    } // Cierre del m√©todo updateSystemPiecesChart

    private void updateUtilizationChart(Statistics stats, double currentTime) { // M√©todo privado que actualiza la gr√°fica de utilizaci√≥n recibiendo las estad√≠sticas y el tiempo actual como par√°metros
        utilizationChart.getData().clear(); // Limpia todos los datos existentes de la gr√°fica de utilizaci√≥n

        XYChart.Series<String, Number> series = new XYChart.Series<>(); // Crea una nueva serie de datos para la utilizaci√≥n
        series.setName("Utilizaci√≥n"); // Establece el nombre de la serie como "Utilizaci√≥n"

        String[] locations = {"LAVADORA", "ALMACEN_PINTURA", "PINTURA", // Define un array con los nombres de las locaciones para las cuales se calcular√° la utilizaci√≥n
                             "ALMACEN_HORNO", "HORNO", "INSPECCION"}; // Continuaci√≥n del array de nombres de locaciones

        for (String locName : locations) { // Bucle for-each que itera sobre cada nombre de locaci√≥n en el array
            Location loc = stats.getLocation(locName); // Obtiene el objeto Location correspondiente a esta locaci√≥n desde las estad√≠sticas
            if (loc != null) { // Condici√≥n que verifica si la locaci√≥n existe (no es null)
                double util = loc.getUtilization(currentTime); // Obtiene el porcentaje de utilizaci√≥n de la locaci√≥n en el tiempo actual
                XYChart.Data<String, Number> data = new XYChart.Data<>(locName, util); // Crea un nuevo punto de datos con el nombre de la locaci√≥n y su utilizaci√≥n
                series.getData().add(data); // Agrega el punto de datos a la serie
            } // Cierre del bloque condicional if
        } // Cierre del bucle for-each

        utilizationChart.getData().add(series); // Agrega la serie completa de datos a la gr√°fica de utilizaci√≥n

        // Aplicar colores a las barras
        applyBarColors(); // Llama al m√©todo para aplicar colores a las barras seg√∫n su valor de utilizaci√≥n
    } // Cierre del m√©todo updateUtilizationChart

    private void updateLocationContentChart(Statistics stats, double currentTime) { // M√©todo privado que actualiza la gr√°fica de contenido de locaciones recibiendo las estad√≠sticas y el tiempo actual como par√°metros
        String[] locations = {"LAVADORA", "ALMACEN_PINTURA", "PINTURA", // Define un array con los nombres de las locaciones para las cuales se actualizar√° el contenido
                             "ALMACEN_HORNO", "HORNO", "INSPECCION"}; // Continuaci√≥n del array de nombres de locaciones

        for (String locName : locations) { // Bucle for-each que itera sobre cada nombre de locaci√≥n en el array
            Location loc = stats.getLocation(locName); // Obtiene el objeto Location correspondiente a esta locaci√≥n desde las estad√≠sticas
            if (loc != null) { // Condici√≥n que verifica si la locaci√≥n existe (no es null)
                XYChart.Series<Number, Number> series = contentSeriesMap.get(locName); // Obtiene la serie de datos correspondiente a esta locaci√≥n desde el mapa de series
                if (series != null) { // Condici√≥n que verifica si la serie existe (no es null)
                    int content = loc.getCurrentContent(); // Obtiene el contenido actual de la locaci√≥n (n√∫mero de piezas)
                    series.getData().add(new XYChart.Data<>(currentTime, content)); // Agrega un nuevo punto de datos a la serie con el tiempo actual y el contenido
                    enforceSeriesLimit(series); // Llama al m√©todo para aplicar downsampling a la serie si excede el l√≠mite de puntos
                } // Cierre del bloque condicional if interno
            } // Cierre del bloque condicional if externo
        } // Cierre del bucle for-each
    } // Cierre del m√©todo updateLocationContentChart

    private void updateAvgSystemTimeChart(Statistics stats, double currentTime) { // M√©todo privado que actualiza la gr√°fica de tiempo promedio en sistema recibiendo las estad√≠sticas y el tiempo actual como par√°metros
        if (stats.getTotalExits() > 0) { // Condici√≥n que verifica si hay al menos una salida (para evitar divisi√≥n por cero)
            double avgTime = stats.getAverageSystemTime(); // Obtiene el tiempo promedio en sistema desde las estad√≠sticas
            avgTimeSeries.getData().add(new XYChart.Data<>(currentTime, avgTime)); // Agrega un nuevo punto de datos a la serie con el tiempo actual y el tiempo promedio
            enforceSeriesLimit(avgTimeSeries); // Llama al m√©todo para aplicar downsampling a la serie si excede el l√≠mite de puntos
        } // Cierre del bloque condicional if
    } // Cierre del m√©todo updateAvgSystemTimeChart

    private void enforceSeriesLimit(XYChart.Series<Number, Number> series) { // M√©todo privado que aplica downsampling a una serie de datos si excede el l√≠mite m√°ximo recibiendo la serie como par√°metro
        ObservableList<XYChart.Data<Number, Number>> data = series.getData(); // Obtiene la lista observable de datos de la serie
        if (data.size() <= MAX_DATA_POINTS) { // Condici√≥n que verifica si el tama√±o de los datos es menor o igual al l√≠mite m√°ximo
            return; // Sale del m√©todo prematuramente si no se excede el l√≠mite
        } // Cierre del bloque condicional if

        ObservableList<XYChart.Data<Number, Number>> downsampled = FXCollections.observableArrayList(); // Crea una nueva lista observable vac√≠a para almacenar los datos reducidos
        for (int i = 0; i < data.size(); i += 2) { // Bucle for que itera sobre los datos tomando cada segundo punto (reducci√≥n a la mitad)
            downsampled.add(data.get(i)); // Agrega el punto actual a la lista de datos reducidos
        } // Cierre del bucle for

        // Garantizar que el √∫ltimo punto siempre se conserve.
        XYChart.Data<Number, Number> lastPoint = data.get(data.size() - 1); // Obtiene el √∫ltimo punto de datos de la lista original
        if (downsampled.isEmpty() || downsampled.get(downsampled.size() - 1) != lastPoint) { // Condici√≥n que verifica si la lista reducida est√° vac√≠a o si su √∫ltimo punto no es el √∫ltimo punto original
            downsampled.add(lastPoint); // Agrega el √∫ltimo punto original a la lista reducida para garantizar que siempre se muestre el punto m√°s reciente
        } // Cierre del bloque condicional if

        data.setAll(downsampled); // Reemplaza todos los datos de la serie con los datos reducidos
    } // Cierre del m√©todo enforceSeriesLimit

    private void applyBarColors() { // M√©todo privado que aplica colores a las barras de la gr√°fica de utilizaci√≥n seg√∫n sus valores
        utilizationChart.applyCss(); // Aplica los estilos CSS a la gr√°fica para asegurar que los nodos est√©n creados
        utilizationChart.layout(); // Ejecuta el layout de la gr√°fica para asegurar que los nodos est√©n posicionados

        for (XYChart.Series<String, Number> series : utilizationChart.getData()) { // Bucle for-each que itera sobre cada serie de la gr√°fica de utilizaci√≥n
            for (XYChart.Data<String, Number> data : series.getData()) { // Bucle for-each interno que itera sobre cada punto de datos de la serie
                if (data.getNode() != null) { // Condici√≥n que verifica si el nodo visual del punto de datos existe (no es null)
                    double value = data.getYValue().doubleValue(); // Obtiene el valor Y del punto de datos (porcentaje de utilizaci√≥n) y lo convierte a double
                    String color = getColorForUtilization(value); // Obtiene el color apropiado para este valor de utilizaci√≥n llamando al m√©todo auxiliar
                    data.getNode().setStyle("-fx-bar-fill: " + color + ";"); // Establece el estilo del nodo (barra) para colorearla con el color obtenido usando CSS
                } // Cierre del bloque condicional if
            } // Cierre del bucle for-each interno
        } // Cierre del bucle for-each externo
    } // Cierre del m√©todo applyBarColors

    private String getColorForUtilization(double utilization) { // M√©todo privado que retorna un color hexadecimal apropiado seg√∫n el valor de utilizaci√≥n recibiendo el valor como par√°metro
        if (utilization < 50) { // Condici√≥n que verifica si la utilizaci√≥n es menor al 50%
            return "#4CAF50"; // Verde // Retorna verde para utilizaci√≥n baja
        } else if (utilization < 80) { // Condici√≥n que verifica si la utilizaci√≥n est√° entre 50% y 80%
            return "#FFC107"; // Amarillo // Retorna amarillo para utilizaci√≥n media
        } else { // Bloque else que se ejecuta si la utilizaci√≥n es mayor o igual al 80%
            return "#2196F3"; // Azul // Retorna azul para utilizaci√≥n alta
        } // Cierre del bloque else
    } // Cierre del m√©todo getColorForUtilization

    private void applyLargeFont(Chart chart) { // M√©todo privado que aplica un tama√±o de fuente grande a una gr√°fica recibiendo la gr√°fica como par√°metro
        chart.setStyle("-fx-font-size: 14px;"); // Establece el tama√±o de fuente de la gr√°fica a 14 p√≠xeles usando CSS
    } // Cierre del m√©todo applyLargeFont

    /** // Inicio del comentario Javadoc del m√©todo
     * Reinicia todas las gr√°ficas // Descripci√≥n del m√©todo
     */ // Fin del comentario Javadoc
    public void reset() { // M√©todo p√∫blico que reinicia todas las gr√°ficas limpiando sus datos
        arrivalsSeriesSystem.getData().clear(); // Limpia todos los datos de la serie de arribos
        exitsSeriesSystem.getData().clear(); // Limpia todos los datos de la serie de salidas
        inSystemSeries.getData().clear(); // Limpia todos los datos de la serie de piezas en sistema
        utilizationChart.getData().clear(); // Limpia todos los datos de la gr√°fica de utilizaci√≥n
        avgTimeSeries.getData().clear(); // Limpia todos los datos de la serie de tiempo promedio

        for (XYChart.Series<Number, Number> series : contentSeriesMap.values()) { // Bucle for-each que itera sobre cada serie en el mapa de series de contenido
            series.getData().clear(); // Limpia todos los datos de la serie actual
        } // Cierre del bucle for-each

        updateCounter = 0; // Reinicia el contador de actualizaciones a 0

    } // Cierre del m√©todo reset
} // Cierre de la clase RealTimeChartsPanel
